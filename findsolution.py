# This script is intended to perform a "brute force" iterative solution of a puzzle consisting of seven hexagonal pieces
# Each piece has numbers 1 - 6 on its sides
# The goal is to line up six of the pieces around a central piece (seven in all) so that the numbers on each adjacent face match

import numpy as np
import pylab
import json
import time

def recursePiecesToSolution(available, alreadyTaken, gamePieces, permutation):
    """
    This function does half of the heavy lifting to solve the puzzle
    It takes in the set of puzzle pieces and recursively iterates through all possible piece positions until it finds the one that solves the puzzle

    :param available: a list of position indices for the gamePieces param, values in available represent elements in gamePieces that have not been selected and placed into position yet
    :param alreadyTaken: a list of position indices for the gamePiecese param, values in alreadyTaken represent elements in gamePieces that have been selected and placed into position
    :param gamePieces: a list of game pieces being recursively tested
    :param permutation: an integer counter indicating the starting permutation number coming into this function call
    :return: an integer, the final permutation counter value generated by this function call
    """

    if (type(available) != list):
        # available is not a list object, (re-)initialize it to an empty list
        available = []

    if (type(alreadyTaken) != list):
        # alreadyTaken is not a list object, (re-)initialize it to an empty list
        alreadyTaken = []

    if (len(available) > 0):
        # One or more game pieces are still available for placement, iterate over the list and test out each element as the next one to use
        for i in range(0, len(available)):
            # Create a new version of available, pop the last element from the list and add it to alreadyTaken
            tempList = available.copy()
            alreadyTaken.append(tempList.pop(i))

            # Recursively call this same function with the new set of available (tempList) and already selected (alreadyTaken) game pieces
            permutation = recursePiecesToSolution(tempList, alreadyTaken, gamePieces, permutation)

            # If the function makes it to this point, the solution has not yet been found (script exits once solution is found), remove the piece that was just
            # added before going to the next one in the list
            alreadyTaken.pop()
    else:
        # All of the game pieces have been set into position, begin iterating over all possible game piece rotations until either a solution is found or
        # all possible rotations for this piece configuration have been tested
        permutation = iterateRotationsToSolution(alreadyTaken, gamePieces, permutation)

        # Print the number of permutations tried so far
        print("{}".format(format(permutation, ",d")))

        # If the function makes it to this point, the solution has not yet been found (script exits once solution is found), this means that this piece configuration
        # has no solutions, clear out alreadyTaken and start over again
        alreadyTaken = []

    return permutation


def iterateRotationsToSolution(pieceOrder, gamePieces, permutationStart):
    """
    This function does the other half of the heavy lifting to solve the puzzle
    It takes in an ordered (i.e. pieces placed into position) set of game pieces and iterates through all possible piece rotations until it finds the
    one that solves the puzzle

    :param pieceOrder: a list of position indices for the gamePieces param that are being recursively tested, it represents the order in which the pieces are laid out in the game board, the first piece is placed in the center and the remaining pieces placed clockwise around it, starting at the top
    :param gamePieces: a list of game pieces that are being recursively tested
    :param permutationStart: an integer counter indicating the starting permutation coming into this function call
    :return: an integer, the final permutation counter value generated by this function call
    """

    permutation = permutationStart

    # Set the maximum value for any element in the rotator and initialize the starting rotator to all zeroes
    rotatorMaxValue = (len(gamePieces[0]) - 1) if (len(gamePieces) > 0) else 0
    moduloCheck = rotatorMaxValue + 1
    rotatorMax = [rotatorMaxValue] * len(gamePieces)
    rotatorStart = [0] * len(gamePieces)
    rotator = [0] * len(gamePieces)
    overflow = False

    # Iterate from the starting rotator configuration (all zeros) to the final rotator configuration (all maximum rotation index value)
    while ((rotator != rotatorStart) or (not overflow)):
        # Increment permutation (counter) for this check
        permutation = permutation + 1

        # Iterate over gamePieces and build boardConfiguration based on each game piece and its desired rotation
        boardConfiguration = []

        for i, pieceIndex in enumerate(pieceOrder):
            # Set the starting face for this piece orientation, and then iterate over the length of the game piece to build an oriented version of the
            # piece based on the desired rotation
            face = rotator[i]
            orientedPiece = []
            for j in range(0, len(gamePieces[pieceIndex])):
                orientedPiece.append(gamePieces[pieceIndex][face])
                face = (face + 1) % moduloCheck

            # Add this properly-oriented game piece to the current board configuration
            boardConfiguration.append(orientedPiece)

        # Conditionally iterate over the board's position adjacencies to see which ones match and which ones don't
        # Once two adjacent faces are found not to have the same value, this configuration fails
        testCount = len(gameBoard["adjacencies"])
        failedAdjacencyTest = False
        i = 0

        while ((not failedAdjacencyTest) and (i < testCount)):
            # Check to see if the two faces in question match and increment i before returning to the top of this loop
            failedAdjacencyTest = (boardConfiguration[gameBoard["adjacencies"][i][0]["position"]][gameBoard["adjacencies"][i][0]["face"]] != boardConfiguration[gameBoard["adjacencies"][i][1]["position"]][gameBoard["adjacencies"][i][1]["face"]])
            i = i + 1

        if (not failedAdjacencyTest):
            # WE FOUND THE SOLUTION!!
            # No adjancy checks failed, this means the values on all adjacent faces on game pieces match
            # Print out the board configuration and exit this script
            print("MATCH FOUND!")
            print("Trial #{}".format(format(permutation, ",d")))

            # Iterate over the game board's positions and print out each one's name and the piece in it
            for i, position in enumerate(gameBoard["positions"]):
                print(position + " - [" + ", ".join(list(map(str, boardConfiguration[i]))) + "]")

            # Print the time required to find this solution
            print("Time Required: {} minutes".format((time.process_time() - startTime) / 60))

            # Exit this script TRIUMPHANTLY!
            exit()

        # If the script has gotten this far, this board configuration did not pass at least on adjacency test, tick the rotator list values by one

        # Initialize i to the right-most element in the rotator array, and carry to True
        i = len(rotator) - 1
        carry = True

        # Iterate i from the starting value to zero, as long as carry stays True
        while ((i >= 0) and (carry)):
            if (carry):
                # carry is true, increment the value at the rotator's current position, wrapping around and back to zero when needed (i.e. when another
                # carry needs to be done)
                rotator[i] = (rotator[i] + 1) % moduloCheck
                carry = (rotator[i] == 0)

            # Move to the previous element in the rotator array
            i = i - 1

        overflow = (rotator == rotatorStart)

    return permutation


if (__name__ == "__main__"):
    # This script has been called directly (i.e. not loaded as a library), run it

    # Initialize the process start time
    startTime = time.process_time()

    # Read the defined game board from the appropriate JSON file
    gameBoard = []
    with open("board.json") as jsonData:
        gameBoard = json.load(jsonData)

    # Read the defined game pieces from the appropriate JSON file
    gamePieces = []
    with open("pieces.json") as jsonData:
        gamePieces = json.load(jsonData)

    # Now pass the pieces into the function that does half of the heavy lifting
    recursePiecesToSolution(list(range(0, len(gamePieces))), [], gamePieces, 0);

    # If this script made it this far without exiting, no solution was found
    print("No Solution Found")
    print("Time Required: {} minutes".format((time.process_time() - startTime) / 60))
