# This script is intended to perform a semi-intelligent iterative solution of a puzzle consisting of seven hexagonal pieces
# Each piece has numbers 1 - 6 on its sides
# The goal is to line up six of the pieces around a central piece (seven in all) so that the numbers on each adjacent face match

import numpy as np
import pylab
import json
import time

def recursePiecesToSolution(available, alreadyTaken, gamePieces, permutation):
    """
    This function does half of the heavy lifting to solve the puzzle
    It takes in the set of puzzle pieces and recursively iterates through all possible piece positions until it finds the one that solves the puzzle

    :param available: a list of position indices for the gamePieces param, values in available represent elements in gamePieces that have not been selected and placed into position yet
    :param alreadyTaken: a list of position indices for the gamePiecese param, values in alreadyTaken represent elements in gamePieces that have been selected and placed into position
    :param gamePieces: a list of game pieces being recursively tested
    :param permutation: an integer counter indicating the starting permutation number coming into this function call
    :return: an integer, the final permutation counter value generated by this function call
    """

    if (type(available) != list):
        # available is not a list object, (re-)initialize it to an empty list
        available = []

    if (type(alreadyTaken) != list):
        # alreadyTaken is not a list object, (re-)initialize it to an empty list
        alreadyTaken = []

    if (len(available) > 0):
        # One or more game pieces are still available for placement, iterate over the list and test out each element as the next one to use
        for i in range(0, len(available)):
            # Create a new version of available, pop the last element from the list and add it to alreadyTaken
            tempList = available.copy()
            alreadyTaken.append(tempList.pop(i))

            # Recursively call this same function with the new set of available (tempList) and already selected (alreadyTaken) game pieces
            permutation = recursePiecesToSolution(tempList, alreadyTaken, gamePieces, permutation)

            # If the function makes it to this point, the solution has not yet been found (script exits once solution is found), remove the piece that was just
            # added before going to the next one in the list
            alreadyTaken.pop()
    else:
        # All of the game pieces have been set into position, begin iterating over all possible game piece rotations until either a solution is found or
        # all possible rotations for this piece configuration have been tested
        permutation = iterateRotationsToSolution(alreadyTaken, gamePieces, permutation)

        # Print the number of permutations tried so far
        # print("{}".format(format(permutation, ",d")))

        # If the function makes it to this point, the solution has not yet been found (script exits once solution is found), this means that this piece configuration
        # has no solutions, clear out alreadyTaken and start over again
        alreadyTaken = []

    return permutation


def iterateRotationsToSolution(pieceOrder, gamePieces, permutationStart):
    """
    This function does the other half of the heavy lifting to solve the puzzle
    It takes in an ordered (i.e. pieces placed into position) set of game pieces and iterates through logical piece rotations until it finds the one that solves
    the puzzle -- if it exists within this game piece ordering

    :param pieceOrder: a list of position indices for the gamePieces param that are being recursively tested, it represents the order in which the pieces are laid out in the game board, the first piece is placed in the center and the remaining pieces placed clockwise around it, starting at the top
    :param gamePieces: a list of game pieces that are being recursively tested
    :param permutationStart: an integer counter indicating the starting permutation coming into this function call
    :return: an integer, the final permutation counter value generated by this function call
    """

    permutation = permutationStart

    # Set the maximum value for any element in the rotator and initialize the starting rotator to all zeroes
    rotatorMaxValue = (len(gamePieces[0]) - 1) if (len(gamePieces) > 0) else 0
    moduloCheck = rotatorMaxValue + 1
    rotatorMax = [rotatorMaxValue] * len(gamePieces)
    rotatorStart = [0] * len(gamePieces)
    rotator = [0] * len(gamePieces)
    positionsRotated = [0] * len(gamePieces)
    overflow = False

    # Initially assume that the solution is within this piece layout (i.e. one of these rotators will succeed), and iterate from the starting rotator
    # configuration (all zeros) until the most significant rotator element (position 0) overflows
    allRotatorsWillFail = False
    while ((not allRotatorsWillFail) and ((rotator != rotatorStart) or (not overflow))):
        # Increment permutation (counter) for this check
        permutation = permutation + 1

        # Iterate over gamePieces and build boardConfiguration based on each game piece and its desired rotation
        boardConfiguration = []

        for i, pieceIndex in enumerate(pieceOrder):
            # Set the starting face for this piece orientation, and then iterate over the length of the game piece to build an oriented version of the
            # piece based on the desired rotation
            face = rotator[i]
            orientedPiece = []
            for j in range(0, len(gamePieces[pieceIndex])):
                orientedPiece.append(gamePieces[pieceIndex][face])
                face = (face + 1) % moduloCheck

            # Add this properly-oriented game piece to the current board configuration
            boardConfiguration.append(orientedPiece)

        # Conditionally iterate over the board's position adjacencies to see which ones match and which ones don't
        # Once two adjacent faces are found not to have the same value, this configuration fails
        testCount = len(gamePieces)
        i = testCount - 1
        failedAdjacencyTest = False

        # Iterate through each of the pieces (except the hub, all other pieces include a hub check) to check adjacencies, bailing out as soon as the tests fail
        while ((not failedAdjacencyTest) and (i > 0)):
          # Check to see if the adjacency tests for this piece are successful

          # All positions will test their front adjacency
          adjacencyTests = [
            "front"
          ]

          # All positions short of the last one will also test their left adjacency
          if ((i + 2) <= testCount):
            adjacencyTests.append("left")

          # The final position (1 is the final, since 0 is the hub, and all hub-related adjacency tests are covered in the radial pieces' tests) will also
          # test its right adjacency
          if (i <= 1):
            adjacencyTests.append("right")

          # Iterate through adjacencyTests and count the ones that are successful
          successfulTests = 0
          for test in adjacencyTests:
            if (boardConfiguration[i][gameBoard["adjacencies"][str(i)][test]["face"]] == boardConfiguration[gameBoard["adjacencies"][str(i)][test]["otherPiece"]["position"]][gameBoard["adjacencies"][str(i)][test]["otherPiece"]["face"]]):
              successfulTests = successfulTests + 1

          # The adjacency tests for this board confugration fails if all of this piece's adjacency tests were not successful
          failedAdjacencyTest = (successfulTests < len(adjacencyTests))
          if (not failedAdjacencyTest):
            # This piece did not fail its adjacency test, move to the next piece and check it
            i = i - 1

          # For pieces beyond the first one being tested, only one successful test means that the no rotator can be valid for this game piece organization
          allRotatorsWillFail = ((i < (testCount - 1)) and (failedAdjacencyTest) and (successfulTests == 1))

        if (not failedAdjacencyTest):
            # WE FOUND THE SOLUTION!!
            # No adjancy checks failed, this means the values on all adjacent faces on game pieces match
            # Print out the board configuration and exit this script
            print("MATCH FOUND!")
            print("Trial #{}".format(format(permutation, ",d")))

            # Iterate over the game board's positions and print out each one's name and the piece in it
            for i, position in enumerate(gameBoard["positions"]):
                print(position + " - [" + ", ".join(list(map(str, boardConfiguration[i]))) + "]")

            # Print the time required to find this solution
            print("Time Required: {} minutes".format((time.process_time() - startTime) / 60))

            # Exit this script TRIUMPHANTLY!
            exit()

        # If the script has gotten this far, this board configuration did not pass at least one adjacency test, tick the rotator list values by one,
        # starting at the piece where the adjacency tests failed

        # Initialize carry to True and iterate i from the starting value to zero, as long as carry stays True
        carry = True
        iOriginal = i
        while ((i >= 0) and (carry)):
            if (carry):
                # carry is true, increment the value at the rotator's current position, wrapping around and back to zero when needed (i.e. when another
                # carry needs to be done)
                rotator[i] = (rotator[i] + 1) % moduloCheck
                carry = (rotator[i] == 0)

            # Move to the previous element in the rotator array
            i = i - 1

        # This rotator overflowed if the original i (i.e. before rotating was zero and the rotator had to carry)
        overflow = (iOriginal == 0) and (carry)

    return permutation


if (__name__ == "__main__"):
    # This script has been called directly (i.e. not loaded as a library), run it

    # Initialize the process start time
    startTime = time.process_time()

    # Read the defined game board from the appropriate JSON file
    gameBoard = []
    with open("board.json") as jsonData:
        gameBoard = json.load(jsonData)

    # Read the defined game pieces from the appropriate JSON file
    gamePieces = []
    with open("pieces.json") as jsonData:
        gamePieces = json.load(jsonData)

    # Now pass the pieces into the function that does half of the heavy lifting
    recursePiecesToSolution(list(range(0, len(gamePieces))), [], gamePieces, 0)

    # If this script made it this far without exiting, no solution was found
    print("No Solution Found")
    print("Time Required: {} minutes".format((time.process_time() - startTime) / 60))
